# THE KNOWLEDGE COMPLEXITY OF INTERACTIVE PROOF SYSTEMS

$...$

## 2. 交互式证明系统。

直观上讲，我们对一个高效的 **定理证明过程** 应该有些什么要求呢？

* （1）可以“证明”一个真定理。
* （2）不应该“证明”一个假定理。
* （3）传递“证明”的过程应该是高效的。也就是说，无论用了多少时间来得出这个证明，它的正确性应该能够高效地被验证。

$...$

验证者将是一个这样一个机器，它能够与证明者进行消息（字符串）交换，其执行时间是的 **概率多项式时间** 的，这里的多项式是 **公共输入** 的长度的多项式。

### 注
>所谓 **公共输入** 见下文

在证明系统中引入概率的同时，我们也将放宽对“证明”的定义。我们的验证者可能以非常小的概率错误地相信一个假命题。对于每个正的常数 $k$ 以及足够大的输入规模 $n$ ，错误概率小于 $n^{-k}$ 。

### 注
>对于任何正的常数 $k$ ，总能找到一个依赖于 $k$ 的常数 $N(k)$ ，只要输入规模 $n > N(k)$ ，错误概率必将小于 $n^{-k}$ 。

### 2.1 交互式图灵机和协议

定义：**交互式图灵机（Interactive Turing Machine，ITM）** 是一种配备有只读输入带、工作带、随机带、一个只读通信带和一个只写通信带的图灵机。随机带包含一个无限长的随机比特序列，但是只能从左到右被读取。我们说一个 **交互式图灵机** 掷硬币，其实是说它读取了自己随机带上的下一个随机比特。

![F-1](./images/kc-of-ips-f-1.jpg "F-1")

图1: 一个交互协议，双向箭头代表可读可写头，R箭头代表只读头，W箭头代表只写头

定义：一个 **交互协议** 是由两个 **交互式图灵机** A和B组成的有序对，其中A和B共享相同的输入带，B的只写通信带是A的只读通信带，反之亦然（注：参考图1）。机器A没有计算上的限制，而机器B的计算时间受限于公共输入长度的多项式。这两台机器轮流处于活跃状态，B先行动。在A的活跃阶段（注：B类似，因此不重复描述），机器A首先使用它的输入带、工作带、通信带和随机带进行一些内部计算；然后，在它的只写通信带上写入一个字符串（给B）。A的第i个消息是A在第i个活跃阶段期间写入其通信带的整个字符串。一旦机器A写入其消息，它就会停止活动。然后，除非协议已经终止，机器B将变为活跃状态。任何一台机器都可以通过在活跃阶段不发送任何消息来终止协议的计算。机器B通过输出“accept“或“reject”并终止协议来接受（或拒绝）其输入。机器B的计算时间是B在所有活跃阶段中的计算时间之和，这个时间受限于输入长度的多项式。这里输入长度可以表示为 $|x|$ 。

### 注
>机器B输出的"accept"或"reject"，是输出到哪里呢？是只写通信带吗？怎么终止？不是没有输出才终止么？抑或是特殊处理？就是B写入了accept或者reject也当作终止？

### 2.2 交互证明系统

定义：设 $L$ 是一个语言，定义在 $`{\{0,1\}}^*`$ 上。设(A, B)是一个交互协议。如果满足以下条件，我们称(A, B)是 $L$ 的交互证明系统：

* （1）对于每个 $k$ ，对于足够大的输入 $x \in L$ ，将其输入到(A, B)，则B必将能够终止，并以至少 $1 - {|x|}^{-k}$ 的概率接受 $x$ 。（这里的概率计算基于A和B的硬币投掷，即读取的随机比特）

* （2）对于每个 $k$ ，对于足够大的输入 $x \notin L$ ，对于任意的 **ITM** A' ，将 $x$ 输入到(A', B)，则B以至多 ${|x|}^{-k}$ 的概率接受。（这里的概率计算基于A'和B的硬币投掷）

### 原文注1
> 通过多次重复上述协议，并选取占多数的结果作为结论，其错误概率可以减小到小于 $2^{-|x|}$ 。

我们现在论证，这个定义符合我们对于高效证明系统的直观要求。条件（1）基本上表示，如果 $x \in L$ ，那么B会以极大的概率接受。条件（2）表示，如果 $x \notin L$，则不存在能够以 **显著** (nonnegligible) 概率成功说服B接受的策略。事实上，B不需要信任（或知道）与其交互的机器的程序，它只需相信自己硬币投掷的随机性即可。

$...$

我们将 **IP** （ **交互多项式时间** ）定义为存在交互证明系统的语言类。

$...$

## 3. 零知识（Zero-knowledge）。

对于零知识，我们将给出一个不仅限于 **交互证明系统** 的，更为一般的定义。对于任何交互协议（A, B），无论它是不是语言 $L$ 的证明系统，我们都将定义该协议是零知识的具体含义。实际上，这个定义甚至不会涉及到B。正如我们将看到的，零知识表明对于每个多项式时间的机器B'，当输入为 $x \in L$ 时，它与A进行交互的过程中，B'在其所有带上“看到”的数据的分布，与某个可以在多项式时间内从 $x$ 计算得到的分布相比，是 **无法区分** 的。因此，我们首先关注随机变量的 **不可区分性** 的概念。

### 注：一些关于B能够从交互中获取知识的直观理解
>（1）交互之后，相比交互之前，B在其所有带上看到的，就是它能够获得的所有新数据。要说B通过交互获取了什么新知识，那这些新知识也必然基于这些新数据。而这些数据包括：随机带和通信输入带。而输入带则可以认为是B在交互之前就已经知道的先验知识。工作带以及通信输出带上的内容，实际上是由B基于随机带、通信输入带以及输入带，在多项式时间内计算出来的，因此可以认为并不是第一手的新数据。
>
>（2）B在交互过程中获取的新知识，可以是以其获取的新数据，附加先验知识，通过多项式时间计算出来的任何数据或者命题。
>   
>（3）1和2中，B执行的多项式时间算法是固定的，公开的，所以任何第三方都可以去复制或者模拟执行。 
>
>（4）如果有一个第三方，比如叫C，它并不和A进行任何交互，但是能够在多项式时间内产生出B在与A交互过程中得到的所有新数据。那么它就可以通过复制B的算法，在多项式时间内计算出B得到的所谓新知识。由于C完全不和A交互，所以它的所谓新知识就不可能是从A处得到的，因此它从A处得到的新知识是0。这就等价于说，即使和A进行了交互的B，在交互过程中得到的新知识也是0。即，交互过程是零知识的。
>
>（5）事实上，这个所谓的C并不一定需要是第三方，它完全可能就是B。如果B首先去执行C做的事情，从而得到了一个它本应和A进行交互才能够得到的数据，然后再把这些数据灌入自己的知识获取算法，那么将得到同样的所谓新知识。可以看出，这个所谓的新知识实际上是0。

### 例子3.1
>（6）考虑一个没有使用随机性的(A,B)系统。从上面对ITM的定义可知，A不受多项式时间限制，因此具有某种超能力。我们假设输入带上的数据是 $y$ ，而A通过其超能力计算出了满足 $y=sha3(x)$ 的 某个$x$ 。为了明确讨论，我们将B的所谓知识计算函数 $Z$ ，定义为计算B在交互之后对 $x$ 的可能情况的判断。在没有任何交互之前，我们应该合理的认为，对于B来说， $x$ 完全未知，因此其分布应该是 $`\{0,...,n-1\}, n>0`$ 上的均匀分布。那么在交互之后，B有没有获取新知识，就可以简单的等价于， $Z$ 算法计算出的 $x$ 的分布情况，是否等价于 $`\{0,...,n-1\}`$ 的均匀分布。如果相等，那就是没有新知识。如果不等，那就是有了新知识。本例中，我们设定(A,B)的交互协议如下： 1. B发送"hello"信息； 2. A发送"1+1=2"信息；3. B结束协议。在这个看似搞笑的简单协议中，我们理应认为，在交互过程中，B不应学到任何关于 $x$ 的新知识，也就是说，其知识计算函数 $Z$ ，在输入为 ("1+1=2") 的情况下，其输入依然是： $x$ 是 $`\{0,...,n-1\}`$ 上的均匀分布。我们这里可以换一种说法，这个协议之所以看起来很搞笑，是因为作为 $Z$ 的输入的数据，太简单了，B完全可以在不和A进行交互的情况下自己快速计算出来（甚至都不用计算）。这里再次提示我们，B自己能够算出来的，都不算做新知识，至少不能算作从A处学到的新知识。
>
>（7）我们稍微修改一下上述系统，就可以得到一个有趣的问题。我们修改其交互协议如下： 1. B发送"hello"; 2. A发送消息"y的后20字节作为以太坊地址的话，其私钥是 $pk$ "； 3. B结束协议。在这个新的交互系统中，作为 $Z$ 的输入，也就是A发送的消息，B应该是没有能力快速计算出来的。那么这个交互过程中，B到底有没有得到新知识呢？一方面，似乎我们可以说没有，因为A给出的信息和 $x$ 看似没有一点关系；而另外一方面，似乎B确实学到了新知识，虽然感觉是不相关的新知识。而实际上，这个协议所传递的信息比第一眼看到要更加复杂，A的消息实际上暗示了 $x = PubkeyFrom(pk)$ ，也就是说A的消息让一个聪明的B可以完全确定 $y=sha3(x)$ 中的 $x$ ，这必然伴随着新知识的获取。这就提示我们，B自己能够算出来的，都不算做新知识。而某些B自己算不出来的，如果也通过直觉判断为没有知识的话，是容易犯错误的。那么，一种做法就是，只有B算得出来的才是零知识，而B算出不来的，就不放在我们对零知识的定义之中，任其自生自灭去吧。
>
>（8）这里我们并没有提到C，而实际上C就是B，B就是C。然后这个例子中，A和B都没有使用随机性，为了定义零知识的概念，我们必然需要扩展到A或B使用了随机性的情形。

### 例子3.2
>（9）类似例子3.1，但是允许B使用随机带上的随机比特。设定其交互协议如下：1. B发送随机数 $`r \in \{0,1\}`$ ；2. A发送 $r$ ； 3. B结束交互。这个协议仍然是简单到无聊。我们应该合理的认为，交互完成之后，B不会学到任何新的知识，尤其是关于 $x$ 的知识。
>
>（10）如果我们将上面的定义套用过来的话，就会碰到问题。在上面我们的定义中，我们期望一个第三方C来产生和交互过程完全一样的数据，或者至少是灌入到知识函数 $Z$ 的所有数据。但如果C无法触及到B的随机带的话，C就不可能生成 $r$ 。而我们前面指出C就是B，B就是C。B如果通过先验知识，以及自己的随机带上的比特，能够自行计算出 $Z$ 的输入数据，那我们也可以合理的认为，B并没有从A处获取新的知识。既然B就是C，C就是B，我们就应该可以允许C去读取B的随机带。也就是说，我们把所谓的零知识定义进行了放宽，我们将允许这个第三方C，在尝试生成和B的所谓新数据相同的数据的时候，去读取B的随机带。在这样的新定义下，在本例中，C就可以得到 $r$ ，并生成A发送的消息，因此自行执行 $Z$ ，得到和B计算出来的同样的所谓新知识。既然C从来没有和A进行交互，那么这个所谓的新知识实际上就是0。
>
>（11）至此，我们仍然还有一种情况没有包含，那就是A使用了随机性。我们必然需要将我们的零知识的概念扩展到这种情况。

### 例子3.3和3.4
>（12）类似例子3.1，但是我们允许A使用随机带上的随机比特。出于简单考虑，我们假设B不使用随机带。设定交互协议如下：1. B发送"hello"; 2. A随机选择一个 $`r \in \{0,1\}`$ ，并发送 $s=x+r \mod 2$ 给B; 3. B结束交互。
>
>（13）为了分析的简单，我们假设 $n=4$ 。那么，上述过程，B到底有没有学到新知识呢？或者明确一点，B到底有没有学到关于 $x$ 的新知识呢？按照我们之前对知识的看法，我们实际上要问的是，在交互之后，B关于 $x$ 的分布的合理判断（称为后验知识），相对于交互之前对于 $x$ 的分布的判断（称为先验知识），有没有发生变化。如果有，那就是学到了新知识，如果没有，那就是没有学到新知识，也就是零知识。这里的先验知识很简单，那就是 $x$ 是 $`\{0,...,n-1\}`$ 的平均分布。对于后验知识，我们可以使用贝叶斯公式。

$$
\begin{align*}
& Pr(x=i|s=j) \\
=& \frac{Pr(x=i,s=j)}{Pr(s=j)} \\
=& \frac{Pr(s=j|x=i) * Pr(x=i)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=j|x=k) * Pr(x=k)}
\end{align*}
$$

>将贝叶斯公式引入上面的例子的话，容易得到

$$
\begin{align*}
& Pr(x=i|s=j) \\
=& \frac{Pr(s=j|x=i) * Pr(x=i)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=j|x=k) * Pr(x=k)} \\
=& \frac{\frac{1}{2} * \frac{1}{4}}{\displaystyle\sum_{k=0}^{3}  \frac{1}{2} * \frac{1}{4}} \\
=& \frac{1}{4}
\end{align*}
$$
> 也就是说，无论交互之后，B看到的 $`s \in \{0,1\}`$ 是多少，它对 $x$ 能够做出的后验判断，依然是一个平均分布，这和先验判断并无二致。因此，我们可以合理的认为这个交互过程是零知识的。
>
>（14）稍微修改一下这个例子，我们可以得到一个有知识的交互，令其为例3.4。在修改后的例子3.4中，我们不再随机选择 $r$ ，而不是以 $3/4$ 的概率选择 $r=0$ ，而 $1/4$ 的概率选择 $r=1$ 。仍然套入上面的公式，我们将得到

$$
\begin{align*}
& Pr(x=0|s=0) \\
=& \frac{Pr(s=0|x=0) * Pr(x=0)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=0|x=k) * Pr(x=k)} \\
=& \frac{\frac{3}{4} * \frac{1}{4}}{\frac{3}{4} * \frac{1}{4}  + \frac{1}{4} * \frac{1}{4} + \frac{3}{4} * \frac{1}{4} + \frac{1}{4} * \frac{1}{4} } \\
=& \frac{3}{8}
\end{align*}
$$
>类似的别的概率将是

|  | $x=0$ | $x=1$ | $x=2$ | $x=3$
|-:|-:|-:|-:|-:|
| $s=0$ | $\frac{3}{8}$ | $\frac{1}{8}$ | $\frac{3}{8}$ | $\frac{1}{8}$
| $s=1$ | $\frac{1}{8}$ | $\frac{3}{8}$ | $\frac{1}{8}$ | $\frac{3}{8}$

> 不难看出，交互之后，无论 $s=0$ 还是 $s=1$ ，B关于 $x$ 的后验知识已经发生了变化。比如，如果 $s=0$ ，B可以合理的判断 $x$ 更有可能是一个偶数。因此，我们应该合理的认为，上面这个交互过程，**不是零知识的**。
>
>（15）那如何扩展我们上面对零知识定义的设想，来覆盖着两个例子呢？对于3.3而言，可以看出，如果把 $x$ 和 $s$ 都当作随机变量的话，它们两者实际上是独立的。也就是说，在每次交互中，我们得到的 $s$ 无论是任何值，我们对 $x$ 的先验知识和后验知识都是完全一样的。对3.4则不同， $s$ 的某些值暗示了 $x$ 更像奇数，而 $s$ 的另外一些值，则暗示了 $x$ 更像偶数， $s$ 和 $x$ 并不独立。于是，我们似乎可以合理的认为，如果把B在交互过程中获取的所谓新数据看作随机变量的话，这个随机变量只要和知识关注的对象 $x$ 是独立的，那我们就可以认为是零知识的，反之则不是零知识的。
>
>（16）回顾我们前面的定义，对零知识，我们要求C（或者B）能够生成出和它所谓新数据完全一样的数据。这就等价于说，对所谓新数据 $s$ 而言，我们能够生成一个和 $s$ 一模一样的 $s'$ 。既然一模一样，那 $s$ 和 $s'$ 作为随机变量的话，肯定是 **完全非独立** 的，因此要说明 $s$ 和 $x$ 是独立的，等价于要说明 $s'$  和 $x$ 是独立的。而 $s'$ 是完全由C（或者B）自行生成的，和 $x$ 的生成过程没有一点点关系，我们似乎应该合理的认为 $s'$ 和 $x$ 是独立的，也就间接说明了 $s$ 和 $x$ 是独立的。在这个论证中，我们真的需要 $s'$ 和 $s$ 是一模一样的么？如果 $s$ 和 $s'$ 并不完全相同，而是某种排列关系，也就是 $`s=j \iff s'=\sigma(j)`$ 的话， 则 $`Pr(x=i|s'=j') = Pr(x=i|s=\sigma^{-1}(j')) = Pr(x=i)`$ 。这是由 $x$ 和 $s$ 之间的独立性所保障的。
>
>（17）让我们仍然例子来说明。在例子3.3中，我们引入一个A'，它和A类似，但是在第2步，改为发送 $s'=r \mod 2$ 。容易看出，A'应该被当作是零知识的，因为它完全没有使用 $x$ 的信息。当然，也可以取用贝叶斯公式对其零知识性进行论证。我们来看，以r的随机性为基础的随机变量 $s$ 和 $s'$ ，列表如下：

|x|r|s|s'
|-:|-:|-:|-
|奇数|0|1|0
|奇数|1|0|1
|偶数|0|0|1
|偶数|1|1|0

> 可以看出，无论 $x$ 和 $r$ 是什么，$s'$ 的取值都将是 $s$ 的取值的一个重排。根据上面的论证，既然 $s'$ 不会产生新知识，我们应该合理的认为 $s$ 也没有产生新知识。
>
>（18）再来看例子3.4。





