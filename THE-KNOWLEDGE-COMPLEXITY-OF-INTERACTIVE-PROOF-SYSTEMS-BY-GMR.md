# THE KNOWLEDGE COMPLEXITY OF INTERACTIVE PROOF SYSTEMS

$...$

## 2. 交互式证明系统。

直观上讲，我们对一个高效的 **定理证明过程** 应该有些什么要求呢？

* （1）可以“证明”一个真定理。
* （2）不应该“证明”一个假定理。
* （3）传递“证明”的过程应该是高效的。也就是说，无论用了多少时间来得出这个证明，它的正确性应该能够高效地被验证。

$...$

验证者将是一个这样一个机器，它能够与证明者进行消息（字符串）交换，其执行时间是的 **概率多项式时间** 的，这里的多项式是 **公共输入** 的长度的多项式。

### 注
>所谓 **公共输入** 见下文

在证明系统中引入概率的同时，我们也将放宽对“证明”的定义。我们的验证者可能以非常小的概率错误地相信一个假命题。对于每个正的常数 $k$ 以及足够大的输入规模 $n$ ，错误概率小于 $n^{-k}$ 。

### 注
>对于任何正的常数 $k$ ，总能找到一个依赖于 $k$ 的常数 $N(k)$ ，只要输入规模 $n > N(k)$ ，错误概率必将小于 $n^{-k}$ 。

### 2.1 交互式图灵机和协议

定义：**交互式图灵机（Interactive Turing Machine，ITM）** 是一种配备有只读输入带、工作带、随机带、一个只读通信带和一个只写通信带的图灵机。随机带包含一个无限长的随机比特序列，但是只能从左到右被读取。我们说一个 **交互式图灵机** 掷硬币，其实是说它读取了自己随机带上的下一个随机比特。

![F-1](./images/kc-of-ips-f-1.jpg "F-1")

图1: 一个交互协议，双向箭头代表可读可写头，R箭头代表只读头，W箭头代表只写头

定义：一个 **交互协议** 是由两个 **交互式图灵机** A和B组成的有序对，其中A和B共享相同的输入带，B的只写通信带是A的只读通信带，反之亦然（注：参考图1）。机器A没有计算上的限制，而机器B的计算时间受限于公共输入长度的多项式。这两台机器轮流处于活跃状态，B先行动。在A的活跃阶段（注：B类似，因此不重复描述），机器A首先使用它的输入带、工作带、通信带和随机带进行一些内部计算；然后，在它的只写通信带上写入一个字符串（给B）。A的第i个消息是A在第i个活跃阶段期间写入其通信带的整个字符串。一旦机器A写入其消息，它就会停止活动。然后，除非协议已经终止，机器B将变为活跃状态。任何一台机器都可以通过在活跃阶段不发送任何消息来终止协议的计算。机器B通过输出“accept“或“reject”并终止协议来接受（或拒绝）其输入。机器B的计算时间是B在所有活跃阶段中的计算时间之和，这个时间受限于输入长度的多项式。这里输入长度可以表示为 $|x|$ 。

### 注
>机器B输出的"accept"或"reject"，是输出到哪里呢？是只写通信带吗？怎么终止？不是没有输出才终止么？抑或是特殊处理？就是B写入了accept或者reject也当作终止？

### 2.2 交互证明系统

定义：设 $L$ 是一个语言，定义在 $`{\{0,1\}}^*`$ 上。设(A, B)是一个交互协议。如果满足以下条件，我们称(A, B)是 $L$ 的交互证明系统：

* （1）对于每个 $k$ ，对于足够大的输入 $x \in L$ ，将其输入到(A, B)，则B必将能够终止，并以至少 $1 - {|x|}^{-k}$ 的概率接受 $x$ 。（这里的概率计算基于A和B的硬币投掷，即读取的随机比特）

* （2）对于每个 $k$ ，对于足够大的输入 $x \notin L$ ，对于任意的 **ITM** A' ，将 $x$ 输入到(A', B)，则B以至多 ${|x|}^{-k}$ 的概率接受。（这里的概率计算基于A'和B的硬币投掷）

### 原文注1
> 通过多次重复上述协议，并选取占多数的结果作为结论，其错误概率可以减小到小于 $2^{-|x|}$ 。

我们现在论证，这个定义符合我们对于高效证明系统的直观要求。条件（1）基本上表示，如果 $x \in L$ ，那么B会以极大的概率接受。条件（2）表示，如果 $x \notin L$，则不存在能够以 **显著** (nonnegligible) 概率成功说服B接受的策略。事实上，B不需要信任（或知道）与其交互的机器的程序，它只需相信自己硬币投掷的随机性即可。

$...$

我们将 **IP** （ **交互多项式时间** ）定义为存在交互证明系统的语言类。

$...$

## 3. 零知识（Zero-knowledge）。

对于零知识，我们将给出一个不仅限于 **交互证明系统** 的，更为一般的定义。对于任何交互协议（A, B），无论它是不是语言 $L$ 的证明系统，我们都将定义该协议是零知识的具体含义。实际上，这个定义甚至不会涉及到B。正如我们将看到的，零知识表明对于每个多项式时间的机器B'，当输入为 $x \in L$ 时，它与A进行交互的过程中，B'在其所有带上“看到”的数据的分布，与某个可以在多项式时间内从 $x$ 计算得到的分布相比，是 **无法区分** 的。因此，我们首先关注随机变量的 **不可区分性** 的概念。

### 注：一些关于B能够从交互中获取知识的直观理解
>（1）交互之后，相比交互之前，B在其所有带上看到的，就是它能够获得的所有新数据。要说B通过交互获取了什么新知识，那这些新知识也必然基于这些新数据。而这些数据包括：随机带和通信输入带。而输入带则可以认为是B在交互之前就已经知道的先验知识。工作带以及通信输出带上的内容，实际上是由B基于随机带、通信输入带以及输入带，在多项式时间内计算出来的，因此可以认为并不是第一手的新数据。
>
>（2）B在交互过程中获取的新知识，可以是以其获取的新数据，附加先验知识，通过多项式时间计算出来的任何数据或者命题。
>   
>（3）1和2中，B执行的多项式时间算法是固定的，公开的，所以任何第三方都可以去复制或者模拟执行。 
>
>（4）如果有一个第三方，比如叫C，它并不和A进行任何交互，但是能够在多项式时间内产生出B在与A交互过程中得到的所有新数据。那么它就可以通过复制B的算法，在多项式时间内计算出B得到的所谓新知识。由于C完全不和A交互，所以它的所谓新知识就不可能是从A处得到的，因此它从A处得到的新知识是0。这就等价于说，即使和A进行了交互的B，在交互过程中得到的新知识也是0。即，交互过程是零知识的。
>
>（5）事实上，这个所谓的C并不一定需要是第三方，它完全可能就是B。如果B首先去执行C做的事情，从而得到了一个它本应和A进行交互才能够得到的数据，然后再把这些数据灌入自己的知识获取算法，那么将得到同样的所谓新知识。可以看出，这个所谓的新知识实际上是0。

### 例子3.1
>（6）考虑一个没有使用随机性的(A,B)系统。从上面对ITM的定义可知，A不受多项式时间限制，因此具有某种超能力。我们假设输入带上的数据是 $y$ ，而A通过其超能力计算出了满足 $y=sha3(x)$ 的 某个$x$ 。为了明确讨论，我们将B的所谓知识计算函数 $Z$ ，定义为计算B在交互之后对 $x$ 的可能情况的判断。在没有任何交互之前，我们应该合理的认为，对于B来说， $x$ 完全未知，因此其分布应该是 $`\{0,...,n-1\}, n>0`$ 上的均匀分布。那么在交互之后，B有没有获取新知识，就可以简单的等价于， $Z$ 算法计算出的 $x$ 的分布情况，是否等价于 $`\{0,...,n-1\}`$ 的均匀分布。如果相等，那就是没有新知识。如果不等，那就是有了新知识。本例中，我们设定(A,B)的交互协议如下： 1. B发送"hello"信息； 2. A发送"1+1=2"信息；3. B结束协议。在这个看似搞笑的简单协议中，我们理应认为，在交互过程中，B不应学到任何关于 $x$ 的新知识，也就是说，其知识计算函数 $Z$ ，在输入为 ("1+1=2") 的情况下，其输入依然是： $x$ 是 $`\{0,...,n-1\}`$ 上的均匀分布。我们这里可以换一种说法，这个协议之所以看起来很搞笑，是因为作为 $Z$ 的输入的数据，太简单了，B完全可以在不和A进行交互的情况下自己快速计算出来（甚至都不用计算）。这里再次提示我们，B自己能够算出来的，都不算做新知识，至少不能算作从A处学到的新知识。
>
>（7）我们稍微修改一下上述系统，就可以得到一个有趣的问题。我们修改其交互协议如下： 1. B发送"hello"; 2. A发送消息"y的后20字节作为以太坊地址的话，其私钥是 $pk$ "； 3. B结束协议。在这个新的交互系统中，作为 $Z$ 的输入，也就是A发送的消息，B应该是没有能力快速计算出来的。那么这个交互过程中，B到底有没有得到新知识呢？一方面，似乎我们可以说没有，因为A给出的信息和 $x$ 看似没有一点关系；而另外一方面，似乎B确实学到了新知识，虽然感觉是不相关的新知识。而实际上，这个协议所传递的信息比第一眼看到要更加复杂，A的消息实际上暗示了 $x = PubkeyFrom(pk)$ ，也就是说A的消息让一个聪明的B可以完全确定 $y=sha3(x)$ 中的 $x$ ，这必然伴随着新知识的获取。这就提示我们，B自己能够算出来的，都不算做新知识。而某些B自己算不出来的，如果也通过直觉判断为没有知识的话，是容易犯错误的。那么，一种做法就是，只有B算得出来的才是零知识，而B算出不来的，就不放在我们对零知识的定义之中，任其自生自灭去吧。
>
>（8）这里我们并没有提到C，而实际上C就是B，B就是C。然后这个例子中，A和B都没有使用随机性，为了定义零知识的概念，我们必然需要扩展到A或B使用了随机性的情形。

### 例子3.2
>（9）类似例子3.1，但是允许B使用随机带上的随机比特。设定其交互协议如下：1. B发送随机数 $`r \in \{0,1\}`$ ；2. A发送 $r$ ； 3. B结束交互。这个协议仍然是简单到无聊。我们应该合理的认为，交互完成之后，B不会学到任何新的知识，尤其是关于 $x$ 的知识。
>
>（10）如果我们将上面的定义套用过来的话，就会碰到问题。在上面我们的定义中，我们期望一个第三方C来产生和交互过程完全一样的数据，或者至少是灌入到知识函数 $Z$ 的所有数据。但如果C无法触及到B的随机带的话，C就不可能生成 $r$ 。而我们前面指出C就是B，B就是C。B如果通过先验知识，以及自己的随机带上的比特，能够自行计算出 $Z$ 的输入数据，那我们也可以合理的认为，B并没有从A处获取新的知识。既然B就是C，C就是B，我们就应该可以允许C去读取B的随机带。也就是说，我们把所谓的零知识定义进行了放宽，我们将允许这个第三方C，在尝试生成和B的所谓新数据相同的数据的时候，去读取B的随机带。在这样的新定义下，在本例中，C就可以得到 $r$ ，并生成A发送的消息，因此自行执行 $Z$ ，得到和B计算出来的同样的所谓新知识。既然C从来没有和A进行交互，那么这个所谓的新知识实际上就是0。
>
>（11）至此，我们仍然还有一种情况没有包含，那就是A使用了随机性。我们必然需要将我们的零知识的概念扩展到这种情况。

### 例子3.3和3.4
>（12）类似例子3.1，但是我们允许A使用随机带上的随机比特。出于简单考虑，我们假设B不使用随机带。设定交互协议如下：1. B发送"hello"; 2. A随机选择一个 $`r \in \{0,1\}`$ ，并发送 $s=x+r \mod 2$ 给B; 3. B结束交互。
>
>（13）为了分析的简单，我们假设 $n=4$ 。那么，上述过程，B到底有没有学到新知识呢？或者明确一点，B到底有没有学到关于 $x$ 的新知识呢？按照我们之前对知识的看法，我们实际上要问的是，在交互之后，B关于 $x$ 的分布的合理判断（称为后验知识），相对于交互之前对于 $x$ 的分布的判断（称为先验知识），有没有发生变化。如果有，那就是学到了新知识，如果没有，那就是没有学到新知识，也就是零知识。这里的先验知识很简单，那就是 $x$ 是 $`\{0,...,n-1\}`$ 的平均分布。对于后验知识，我们可以使用贝叶斯公式。

$$
\begin{align*}
& Pr(x=i|s=j) \\
=& \frac{Pr(x=i,s=j)}{Pr(s=j)} \\
=& \frac{Pr(s=j|x=i) * Pr(x=i)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=j|x=k) * Pr(x=k)}
\end{align*}
$$

>将贝叶斯公式引入上面的例子的话，容易得到

$$
\begin{align*}
& Pr(x=i|s=j) \\
=& \frac{Pr(s=j|x=i) * Pr(x=i)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=j|x=k) * Pr(x=k)} \\
=& \frac{\frac{1}{2} * \frac{1}{4}}{\displaystyle\sum_{k=0}^{3}  \frac{1}{2} * \frac{1}{4}} \\
=& \frac{1}{4}
\end{align*}
$$
> 也就是说，无论交互之后，B看到的 $`s \in \{0,1\}`$ 是多少，它对 $x$ 能够做出的后验判断，依然是一个平均分布，这和先验判断并无二致。因此，我们可以合理的认为这个交互过程是零知识的。
>
>（14）稍微修改一下这个例子，我们可以得到一个有知识的交互，令其为例3.4。在修改后的例子3.4中，我们不再随机选择 $r$ ，而不是以 $3/4$ 的概率选择 $r=0$ ，而 $1/4$ 的概率选择 $r=1$ 。仍然套入上面的公式，我们将得到

$$
\begin{align*}
& Pr(x=0|s=0) \\
=& \frac{Pr(s=0|x=0) * Pr(x=0)}{ \displaystyle\sum_{k=0}^{n-1} Pr(s=0|x=k) * Pr(x=k)} \\
=& \frac{\frac{3}{4} * \frac{1}{4}}{\frac{3}{4} * \frac{1}{4}  + \frac{1}{4} * \frac{1}{4} + \frac{3}{4} * \frac{1}{4} + \frac{1}{4} * \frac{1}{4} } \\
=& \frac{3}{8}
\end{align*}
$$
>类似的别的概率将是

|  | $x=0$ | $x=1$ | $x=2$ | $x=3$
|-:|-:|-:|-:|-:|
| $s=0$ | $\frac{3}{8}$ | $\frac{1}{8}$ | $\frac{3}{8}$ | $\frac{1}{8}$
| $s=1$ | $\frac{1}{8}$ | $\frac{3}{8}$ | $\frac{1}{8}$ | $\frac{3}{8}$

> 不难看出，交互之后，无论 $s=0$ 还是 $s=1$ ，B关于 $x$ 的后验知识已经发生了变化。比如，如果 $s=0$ ，B可以合理的判断 $x$ 更有可能是一个偶数。因此，我们应该合理的认为，上面这个交互过程，**不是零知识的**。
>
>（15）从这两个例子，我们不难看出，B从得到的新数据 $s=j$ 中学到了东西，那就意味着对某个 $i \neq i'$ ， $`Pr(x=i|s=j) \neq Pr(x=i'|s=j)`$ 。只有这样，B才能够在得到了 $s=j$ 之后，通过贝叶斯公式，得到一个和先验知识不同的关于 $x$ 的分布的判断。值的注意的是，我们这里假定的先验知识是， $x$ 符合一个平均分布。但如果先验知识是 $x$ 符合正态分布的话，我们也希望 $`Pr(x|s=j)`$ 应该符合同样的正态分布。总而言之，在得到了 $s=j$ 的数据之后，我们希望根据贝叶斯公式反推的 $x$ 的分布，与先验知识相比，应该并无变化。在这样的假设之下，我们可以合理的认为B并没有从交互中学到任何新的知识。
>
>（16）如果考虑到 $x$ 可能有别的分布的话，我们上面的讨论实际上等价于，无论 $s=j$ 是多少， $`Pr(x=i|s=j)=Pr(x=i)`$ ，这个公式实际上就是 $x$ 和 $s$ 两个随机变量是 **独立** 的定义。由此可以看出，我们可以合理的将 **零知识** 某种意义上定义为 $x$ 和B的所谓新数据 $s$ 的独立性之上。只要我们能够说明 $s$ 和 $x$ 是独立的，那就可以说明交互过程是零知识的。一种最简单的情形是，如果 $s$ 的生成和 $x$ 没有任何关系，那我们理应认为 $s$ 和 $x$ 是独立的，因此是零知识的。比如说，如果我们把例子3.4中，A发送给B的消息改为 $`s=r \mod 2`$ ，就能得到一个这样的例子。
>
>（17）在 **独立性** 的基础上，我们来考虑这样一种做法。如果我们能够找到一个随机变量 $s'$ ，并且能够说明：1. $s'$ 和 $x$ 是独立的； 2. $s'$ 和 $s$ 是完全非独立的，那我们就间接说明了 $s$ 和 $x$ 是独立的。这里的完全非独立的概念可以是： $s=j \iff s'=j'$ ，也就是说，虽然 $s$ 和 $s'$ 的分布是不一样的，但是这种不一样，实际上只是某种取值的重新排列而已，比如说最简单的 $s'=s+1$ 就是如此。为了谈到随机变量，我们必然需要依赖于一个随机性的来源。在这里，我们讨论 $s$ 和 $s'$ 的完全非独立性，是基于A的随机带上的随机比特的。也就是说，对于A的随机带的任何一种配置， $s$ 的取值和 $s'$ 的取值有某种一一对应的固定关系。我们考虑例3.3中的情况。取 $s'=r$ ，那么 $`s'=r \iff s=(r+x) \mod 2`$ 。无论 $x$ 的具体值是什么， $s'$ 和 $s$ 之间都能保持这样一种一一对应的关系，因此我们说 $s'$ 和 $s$ 是完全非独立的。但是，可以看出 $s'$ 和 $x$ 是完全独立的，这就间接说明了 $s$ 和 $x$ 是完全独立的，也就是说例子3.3是零知识的。
>
>（18）结合我们之前对零知识的定义的设想，我们在此就可以扩展其定义，来包含类似3.3和3.4的例子了。在合理的定义中，对于零知识而言，我们判断，存在一个C（或者B自己），能够依赖于A的随机带，多项式时间计算出一个数据 $s'$ ，其取值和所谓的新数据 $s$ 保持一个固定的一对一对应的关系。该对应关系可能具体依赖于 $x$ 而不为C所知，但是这种对应关系的存在是确定无疑的。如果存在这样的C，我们就认为交互式零知识的，如果不存在，那就至少不是我们能够确认的零知识。
>
>（19）我们可以在这个模型中，加入B使用了随机带的情况。总体而言，我们需要去寻找某个C。C的计算能力是多项式的。C能够读取B的输入以及随机带，从而去模仿B，因为我们可以合理的认为B自己能够计算出来的，都不算做从A处学到的新知识。C能够读取A的随机带，并能够某种意义上精确模拟A对B的通信内容（在重排的意义上）。如果我们能够找到这样的C，因为C并不拥有A的超能力，除了A的随机比特之外，C也不和A进行任何交互，我们理应认为C并没有从A处学到任何知识。上面的论证表明，C的存在就表明了B在和A进行交互的过程中，并没有学到任何新知识。于是，我们可以合理的将零知识性，定义为C的存在性。对于某个交互系统（A，B），如果我们能够指出某个C符合我们的要求，我们就说明了这个交互系统的零知识性。
### 例子3.5
>（20）这里我们考虑一个真实的例子。设定一个阶为素数 $p$ 的循环群 $G$ ，其生成元为 $g$ 。设定这个群上的DLP问题是难解的，也就是说，给定 $y \in G$ ，除非具有超能力，不然我们无法求解 $y=g^x$ 中的 $x$ 。对于 $x$ ，我们只能假定它是一个在 $`\{0,...,p-1\}`$ 上平均分布的随机变量。在协议中，A需要向B证明它知道 $x$ 的具体值。协议如下： 1. A选择一个随机数 $`r \in \{0,...,p-1\}`$ ，并将 $Comm=g^r$ 发送给B； 2. B随机选择一个数 $`z\in \{0,1\}`$ ，并发送给A； 3. A根据 $z$ 做出选择。如果 $z=0$ ，则发送 $s=s_1=r$ 给B。如果 $z=1$ ，则发送 $`s=s_2=(x + r) \mod (p-1)`$ 给B； 4. $z=0$ 时， B检查 $`g^s = Comm`$ 。 $z=1$ 时，B检查 $`g^s = g^{x+r \mod (p-1)} = y\cdot Comm`$ ，并结束交互。
>
>（21）我们在此只关注协议的零知识性，也就是是否存在一个C，满足我们前面提到的要求呢。首先C知道 $y$ ，其次C知道B将在第二步如何选择 $z$ ，因为C是知道B的随机带的。因此我们可以设计C如下： 1. 如果 $z=0$ ，则选择和A一样的 $r$ （根据A的随机带），然后发送 $Comm=g^r$ 给B。如果 $z=1$ ，则发送 $`Comm=g^{r-x} = g^r/y`$ 给B。3. 如果 $z=0$ ，把 $r$ 发给B；如果 $z=1$，把 $`r \mod (p-1)`$ 发送给B。容易证明，B和A交互最后能够 accept，等价于B和C交互最后能够accept。我们这里着重去讨论其零知识性。
>
>（22）在整个交互中，B看到的所谓新数据是 $D=(Comm,s)$ ，因此我们只需要去讨论C给出的 $D_C$ 和A给出的 $D_A$ ，作为随机变量（基于A的随机比特），是否是 **完全非独立** 的，即可。我们按照B的随机比特，也就是 $z$ 分开讨论。对于 $z=0$ ，C给出的 $Comm_C=g^r$ ， 和A给出的 $Comm_A=g^r$ 完全一致。而 C给出的 $s_C=r$ ，和A给出的$s_A=r$ 完全一致。因此，可以说 $z=0$ 时， C给出的 $D_C=(Comm_C,s_C)$ 和 A给出的数据完全一致，因此也就是完全非独立。对于 $z=1$ ，C给出的 $`Comm_C=g^{r-x} = g^r y^{-1}`$ ， A给出的 $`Comm_A=g^r`$ ，在阶为素数 $p$ 的循环群中， $Comm_C$ 和 $Comm_A$ 是一个依赖于 $x$ 的重排关系。而C给出的 $s_C=r \mod (p-1)$ 和 A给出的 $s_A=x+r \mod (p-1)$ 显然也是一个依赖于 $x$ 的重排关系。我们可以得出结论，无论 $z=0$ 还是 $z=1$ ，$D_C$ 和 $D_A$ 之间都保持了一种依赖于 $x$ 的重排关系，也就是说，作为随机变量的 $D_C$ 和 $D_A$ 之间，是 **完全非独立** 的。由于C完全不和A交互，因此我们可以合理的认为该协议是零知识的。
>
>（23）上面讨论的B是诚实的，也就是说它遵从了该协议，我们来看一个骗子B'可能如何。对于A来说，B'唯一能够欺骗的地方就是关于 $z$ 的计算。我们设定 $z$ 不再仅仅是直接从随机带上读取，而是一个依赖于 $Comm$ 和随机带的函数，比如 $z(Comm,randombits)$ 。由定义可知，B没有超能力，因此函数 $z$ 必然是确定多项式时间的。
