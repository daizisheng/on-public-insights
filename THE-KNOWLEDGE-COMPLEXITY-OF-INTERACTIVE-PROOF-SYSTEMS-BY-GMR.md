# THE KNOWLEDGE COMPLEXITY OF INTERACTIVE PROOF SYSTEMS

$...$

## 2. 交互式证明系统。

直观上讲，我们对一个高效的 **定理证明过程** 应该有些什么要求呢？

* （1）可以“证明”一个真定理。
* （2）不应该“证明”一个假定理。
* （3）传递“证明”的过程应该是高效的。也就是说，无论用了多少时间来得出这个证明，它的正确性应该能够高效地被验证。

$...$

验证者将是一个这样一个机器，它能够与证明者进行消息（字符串）交换，其执行时间是的 **概率多项式时间** 的，这里的多项式是 **公共输入** 的长度的多项式。

### 注
>所谓 **公共输入** 见下文

在证明系统中引入概率的同时，我们也将放宽对“证明”的定义。我们的验证者可能以非常小的概率错误地相信一个假命题。对于每个正的常数 $k$ 以及足够大的输入规模 $n$ ，错误概率小于 $n^{-k}$ 。

### 注
>对于任何正的常数 $k$ ，总能找到一个依赖于 $k$ 的常数 $N(k)$ ，只要输入规模 $n > N(k)$ ，错误概率必将小于 $n^{-k}$ 。

### 2.1 交互式图灵机和协议

定义：**交互式图灵机（Interactive Turing Machine，ITM）** 是一种配备有只读输入带、工作带、随机带、一个只读通信带和一个只写通信带的图灵机。随机带包含一个无限长的随机比特序列，但是只能从左到右被读取。我们说一个 **交互式图灵机** 掷硬币，其实是说它读取了自己随机带上的下一个随机比特。

![F-1](./images/kc-of-ips-f-1.jpg "F-1")

图1: 一个交互协议，双向箭头代表可读可写头，R箭头代表只读头，W箭头代表只写头

定义：一个 **交互协议** 是由两个 **交互式图灵机** A和B组成的有序对，其中A和B共享相同的输入带，B的只写通信带是A的只读通信带，反之亦然（注：参考图1）。机器A没有计算上的限制，而机器B的计算时间受限于公共输入长度的多项式。这两台机器轮流处于活跃状态，B先行动。在A的活跃阶段（注：B类似，因此不重复描述），机器A首先使用它的输入带、工作带、通信带和随机带进行一些内部计算；然后，在它的只写通信带上写入一个字符串（给B）。A的第i个消息是A在第i个活跃阶段期间写入其通信带的整个字符串。一旦机器A写入其消息，它就会停止活动。然后，除非协议已经终止，机器B将变为活跃状态。任何一台机器都可以通过在活跃阶段不发送任何消息来终止协议的计算。机器B通过输出“accept“或“reject”并终止协议来接受（或拒绝）其输入。机器B的计算时间是B在所有活跃阶段中的计算时间之和，这个时间受限于输入长度的多项式。这里输入长度可以表示为 $|x|$ 。

### 注
>机器B输出的"accept"或"reject"，是输出到哪里呢？是只写通信带吗？怎么终止？不是没有输出才终止么？抑或是特殊处理？就是B写入了accept或者reject也当作终止？

### 2.2 交互证明系统

定义：设 $L$ 是一个语言，定义在 $`{\{0,1\}}^*`$ 上。设(A, B)是一个交互协议。如果满足以下条件，我们称(A, B)是 $L$ 的交互证明系统：

* （1）对于每个 $k$ ，对于足够大的输入 $x \in L$ ，将其输入到(A, B)，则B必将能够终止，并以至少 $1 - {|x|}^{-k}$ 的概率接受 $x$ 。（这里的概率计算基于A和B的硬币投掷，即读取的随机比特）

* （2）对于每个 $k$ ，对于足够大的输入 $x \notin L$ ，对于任意的 **ITM** A' ，将 $x$ 输入到(A', B)，则B以至多 ${|x|}^{-k}$ 的概率接受。（这里的概率计算基于A'和B的硬币投掷）

### 原文注1
> 通过多次重复上述协议，并选取占多数的结果作为结论，其错误概率可以减小到小于 $2^{-|x|}$ 。

我们现在论证，这个定义符合我们对于高效证明系统的直观要求。条件（1）基本上表示，如果 $x \in L$ ，那么B会以极大的概率接受。条件（2）表示，如果 $x \notin L$，则不存在能够以 **显著** (nonnegligible) 概率成功说服B接受的策略。事实上，B不需要信任（或知道）与其交互的机器的程序，它只需相信自己硬币投掷的随机性即可。

$...$

我们将 **IP** （ **交互多项式时间** ）定义为存在交互证明系统的语言类。

$...$

## 3. 零知识（Zero-knowledge）。

对于零知识，我们将给出一个不仅限于 **交互证明系统** 的，更为一般的定义。对于任何交互协议（A, B），无论它是不是语言 $L$ 的证明系统，我们都将定义该协议是零知识的具体含义。实际上，这个定义甚至不会涉及到B。正如我们将看到的，零知识表明对于每个多项式时间的机器B'，当输入为 $x \in L$ 时，它与A进行交互的过程中，B'在其所有带上“看到”的数据的分布，与某个可以在多项式时间内从 $x$ 计算得到的分布相比，是 **无法区分** 的。因此，我们首先关注随机变量的 **不可区分性** 的概念。

### 注：一些关于B'能够从交互中获取知识的直观理解
>（1）交互之后，相比交互之前，B'在其所有带上看到的，就是它能够获得的所有新数据。要说B'通过交互获取了什么新知识，那这些新知识也必然基于这些新数据。而这些数据包括：随机带和通信输入带。而输入带则可以认为是B'在交互之前就已经知道的先验知识。工作带以及通信输出带上的内容，实际上是由B'基于随机带、通信输入带以及输入带，在多项式时间内计算出来的，因此可以认为并不是第一手的新数据。

>（2）B'在交互过程中获取的新知识，可以是以其获取的新数据，附加先验知识，通过多项式时间计算出来的任何数据或者命题。
    
>（3）1和2中，B'执行的多项式时间算法是固定的，公开的，所以任何第三方都可以去复制或者模拟执行。 

>（4）如果有一个第三方，比如叫C，它并不和A进行任何交互，但是能够在多项式时间内产生出B'在与A交互过程中得到的所有新数据。那么它就可以通过复制B'的算法，在多项式时间内计算出B'得到的所谓新知识。由于C完全不和A交互，所以它的所谓新知识就不可能是从A处得到的，因此它从A处得到的新知识是0。这就等价于说，即使和A进行了交互的B'，在交互过程中得到的新知识也是0。即，交互过程是零知识的。

>（5）所以问题归结于，C到底能不能快速计算出B'得到的所谓新数据。在上述系统中，由于A和B'都使用了随机带，所以，B'得到的所谓新数据实际上并不是确定性的，而是一个依赖于随机带上的随机比特的随机变量（或者随机变量序列）。如果A和B'使用的随机比特够多的话，那么C直接得到和B'的所谓新数据一摸一样的的数据的概率可能极低。实际上这里还有一个小问题，A的计算能力并不受多项式时间所限制，所以有多项式计算时间限制的C，在生成由A发送给B'的通信数据的时候，可能存在障碍。

### 注：关于随机带和A的超能力
>（6） 上面提到，在C进行数据计算的时候，必然面临一个问题，那就是它可能无法计算出A发送给B'的消息，即使不去考虑随机带的问题。这实际上引出了另外一个问题。我们来考虑一个深入的问题，那就是在一个（A,B') 系统中，B'获取的所谓新知识（如果有的话）到底来自何处。输入带是B'的先验知识，所以并不算。B'的工作带、通信输出带都是自己计算出来的二手数据，所以也不能作数。所以对B'来说，来自A的通信内容，以及来自随机带的随机比特才是其所谓新知识的根本来源。先粗暴的假设随机带并不产生新知识，那么新知识必然来自A的通信内容。再看A是怎么产生通信输出的，其算法的输入是输入带，随机带以及来自B'的通信内容，如果仍然粗暴的放弃随机带的话，那么新知识必然来自输入带或者B'的通信内容，但是我们知道这些要么是B'的先验知识，要么是B'根据先验知识算出来的二手知识，不应该成为新知识的来源。问题出在哪里？其实问题出在A拥有超能力，也就是说虽然A采用了B'的先验知识以及二手知识作为输入，他仍然可能产生新知识，至少对B'来说是这样的。举例来说，对B'来说，通过先验知识（即输入带），它知道了一个大数 $N$ ，但是由于计算能力有限，它无法知道 $N$ 的素分解。但是，A却可以去分解 $N$ ，然后告诉B'分解结果，这样B'就获得了新知识。正因为B'无法在多项式时间内去模拟拥有超能力的A的算法，所以B'通过和A通信从而可能获得新知识。

>（7）那我们粗暴的丢弃了的随机带呢？难道随机带不能产生新知识么？这似乎是一个哲学问题。举一个简单的例子，A拥有分解 $N$ 的超能力，但它并不把分解结果告诉B'，而是简单的把自己的随机带上的第一个随机比特告诉给B'，那么在这个过程中B'到底有没有学到新知识呢？可以说是有的，毕竟B'知道了A的随机带上的第一个随机比特，这一点在交互之前确实是不知道的，但这似乎和我们想要去涉及的新知识没有关系。 **因此，作为零知识的定义，我们似乎应该直接定义随机带提供的新知识是0。**

>（8）再次回到一个哲学问题，一个系统中，先后执行了X和Y两个步骤。如果X步骤不产生新知识，Y步骤也不产生新知识，那我们似乎可以合理的认为X和Y两个步骤都执行了，也不会有新知识产生。反过来说，如果X和Y都执行了之后，有新知识产生，那么要么在X中，要么在Y中，必然有新知识产生。

>（9）对系统(A,B')，如果我们把整个交互过程分为两个阶段，第一个阶段是准备输入带，以及准备A和B'的随机带，也就是通过比如抛硬币的方式把各自的随机带固定下来；第二个阶段是正常的交互阶段，只是交互过程中在随机带上读取的所谓随机比特在第一个阶段就已经固定下来了。我们来分析，在第一个阶段结束的那一刻，系统应该并没有产生任何新知识。如果一个第三方C在第二阶段再进入，也就是说它能够去读取已经固定下来的A和B'的随机带，但不和A交互，就能够产生和后续B'看到的所谓新数据完全一样的数据的话，那么我们就可以合理的认为，B'在和A交互的过程中没有学到任何新的知识。

>（10）在9中，虽然我们引入了一个第三方C，但是因为C是多项式时间的，所以实际上C可以就是B'自己，也就是说B'看到的所谓新数据，是B'自己可以以A和B'的随机带，以及输入带为基础，多项式时间算出来的。也就是说，除了读取A的随机带之外，B'都不用和A交互，就能得到所谓的新知识，那这样的新知识其实仍然是先验知识，而真正的新知识实际上是0。

### 注：一个例子

>（11）一个 **定义** 是不是好，取决于两方面。一方面，定义所规定的范围必然是合理的，不存在鱼目混珠的情况。另外一方面，定义需要包含尽量多的合理情况，甚至包含得越多，定义本身的质量就越好。上面，我们推导出一种看似合理的对零知识的模糊定义，下面我用例子来判断它是不是好。

>（12）(A,B')设置如下。1. 公共输入是一个比特币地址 $addr$ 。2.
协议开始之后，首先B'向A发送一个固定消息"hello"，然后A通过自己的超能力，计算出了 $addr$ 的私钥 $`pk \in \{0,...,n-1\} ,n>1`$ 。为简单起见，我们可以假设 $pk$ 可以是 $0$ 到 $n-1$ 中的任何一个数，而且取值任何一个数的概率是相同的，也就是 $\frac{1}{n}$ 。3. A通过自己的随机带，获得一个随机数 $`r \in \{0,...,n-1\}`$ ，并将 $`y = (pk + r) \mod n`$ 发送给B'。 4. B'宣布协议结束。

>（13）在上面的假想例子中，B'到底有没有从A出得到新知识呢？或者说，上述交互过程是不是零知识的呢？套用我们之前的模糊定义，在第一个阶段完成之后，随机带已经写死，等价于说 $r$ 已经固定。这个时候C参与进来了。在12中，B'获取的新数据只有 $y$ ，那么C基于 $addr$ ，以及 $r$ ，能够有效的计算出 $y$ 么？如果C能够计算出 $y$ ，那么由于 $`pk = (y - r) \mod n`$ ，C就能够有效的计算出 $pk$ ，据我们所知， C这样就拥有了超能力，是不合理的。因此，貌似这个交互过程，并不符合我们之前所定义的零知识的模糊概念。然而，这个简单的过程，从直觉上说应该有是零知识的。这就说明，我们对零知识的模糊定义，虽然合理，但是过于狭隘。

>（14）为了将这个简单的例子也包含进我们对零知识的定义范围之中，我们来对这个例子进行详细的分析。为了简单起见，我们设 $n=2$ 。$n$ 设置为如此之小的一个值，让C似乎并不需要什么超能力就能计算出 $pk$ 了，所以请注意，这里只是为了说明起来简单起见而已。 $n$ 设置为 2 之后，我们改变C的策略，它的目标将不再是生成 $y$ ，而是直接输出 $y'=r$ 。另外，我们假设B'用来计算所谓新知识的程序，可以用确定性多项式时间算法 $Z(addr,y)$ 来表示。算法 $Z$ 一方面接受先验知识 $addr$ 作为输入，一方面接受B'看到的所有新数据  $y$ 作为输入。这里 $Z$ 是确定性的多项式时间算法，因此只要输入是一样的，其输出也必将完全一样。下面表格进行分类讨论。

> 先令 $pk=1$

| $r$ 取值 |  概率   |  B'和A交互所得 | 从A得到知识  | C产生数据 | C自己计算知识
|---------|:-------:|-------------:|------------:|----------:|------------
| 0       |   0.5   | $y=1$        | $Z(addr,1)$ | $y'=r=0$  | $Z(addr,0)$
| 1       |   0.5   | $y=0$        | $Z(addr,0)$ | $y'=r=1$  | $Z(addr,1)$
    
> 由于C和A完全没有交互，所以C所得的知识中新知识量为0，也就是在某种度量之下， $Z(addr,0)$ 和 $Z(addr,1)$ 中新知识量为0。这里我们看到，B'和A交互之后，得到的所谓知识其实还是 $Z(addr,0)$ 和 $Z(addr,1)$ ，所以在某种度量之下，其新知识量必然也是0。

> 而如果令 $pk=0$ ，那么必然有 $y=y'=r$ ，也就是C产生的数据和B'获得的所谓新数据完全一样，这就符合我们之前的定义了。

>（15）这似乎给了我们一种新的启发。为了把这个新例子也包含进我们的定义范围之中，我们可以不强求C的输出和B'的所谓新数据完全一样，只要是说在A的随机带上的比特处于一种情况下的C的输出和另外一种情况下的B'所得新数据匹配即可。这有点像说，如果把A的随机比特各种情况遍历一遍的话，C的输出某种意义上是B'的所谓新数据的一种重新排列。或者更数学化的说，在A的随机比特基础之上，B'的所谓新数据作为一个随机变量的分布，和C产生的数据作为一个随机变量的分布，是一样的。如下表所示。

> $pk=1$ 时

| | =0 的概率 | =1的概率
|-:|-:|-
|C的输出 $y'=r$ | 0.5 | 0.5
|B'的新数据 $y=pk+r$ | 0.5 | 0.5

> $pk=0$ 时

| | =0 的概率 | =1的概率
|-:|-:|-
|C的输出 $y'=r$ | 0.5 | 0.5
|B'的新数据 $y=pk+r$ | 0.5 | 0.5




    
